---
title: "Análisis de datos con `Tidyverse`"
author: "Roger M. López"
format: 
  revealjs:
    theme: serif
    #self-contained: true
    css: custom.css
  #  highlight-style: github
    toc: true
    toc-title: "Contenido"
    toc-location: left
    toc-depth: 1
    slide-number: true
    link-external-newwindow: true
    preview-links: true
    auto-stretch: false
    transition: fade
    #number-sections: true
editor: source
echo: true
filters:
  - timer
---

# `Tidyverse`: una introducción

Uno de los marcos para el análisis de datos más importantes del ecosistema de `R` es `Tidyverse`, que incluye una serie de paquetes diseñados para la manipulación y visualización de datos. En esta presentación, exploraremos cómo utilizar `Tidyverse` para realizar análisis de datos de manera eficiente y efectiva.

## Flujo de trabajo

[Tidyverse](https://www.tidyverse.org/) es un conjunto de *paquetes* o *librerías* de `R` diseñados para la ciencia de datos. Proporciona herramientas para todo el flujo de trabajo.

. . .

```{r}
#| echo: false
#| fig-align: center
knitr::include_graphics("Imagenes/data-science.png")
```

. . .

En este curso vamos a concentrarnos en `readr` para importar datos, `dplyr` para manipular datos, y `ggplot2` para visualizarlos.

## Instalación de librerías

Una librería es un conjunto de funciones y datos que se pueden utilizar en `R`. Al ser un lenguaje de *código abierto*, `R` cuenta con una amplia variedad de librerías desarrolladas por la comunidad. Estas librerías se pueden instalar y cargar en el entorno de trabajo para utilizar sus funciones.

. . .

Para instalar una librería, se utiliza la función `install.packages()`. Por ejemplo, para instalar el paquete `tidyverse`, se puede ejecutar:

```{r}
#| eval: FALSE
install.packages("tidyverse")
```

. . .

<br>

::: {.callout-note title="Nota"}
Es importante destacar que la instalación de paquetes *es necesaria una sola vez*. Una vez instalado, el paquete estará disponible para su uso en futuras sesiones de `R`. Por lo tanto, no es necesario volver a instalarlo cada vez que se inicie `R`.
:::

## Cargado de librerías

Para utilizar las funciones de un paquete, es necesario cargarlo en el *entorno de trabajo* con la función `library()`, por ejemplo:

```{r}
#| message: true
library(tidyverse)
```

. . .

-   **Versiones**. `tidyverse` carga varios paquetes, entre ellos `dplyr` en su versión 1.1.4 o `forcats` versión 1.0.0, etc.
-   **Conflictos**. Algunos paquetes tienen funciones que se llaman igual que las de otros paquetes ya cargados. Por ejemplo, `dplyr` y `stats` tienen una función llamada `filter()`. En este caso, `dplyr` se carga por encima de `stats`. Si queremos utilizar la de `stats`, debemos especificar el paquete con `stats::filter()`.

------------------------------------------------------------------------

::: {.callout-note title="Nota"}
Siempre es posible cargar un paquete específico sin cargar todo `tidyverse` utilizando la función `library()` con el nombre del paquete deseado, por ejemplo, `library(dplyr)`. Esto es útil si solo necesitas funciones de un paquete específico para evitar el consumo de memoria y posibles conflictos con otras funciones de paquetes cargados.
:::

# Importación de datos con `readr`

El primer paso en el análisis de datos es importar los datos a `R` y representarlos a través de un *dataframe*. El paquete `readr` proporciona funciones para leer datos de diferentes formatos, como *.csv* o *.txt*, entre otros.

## Leyendo archivos *.csv*

El formato *.csv* es un formato de archivo plano que se utiliza comúnmente. Existen varias librerías en `R` que permiten leerlos. En este curso, utilizaremos la librería `readr` (al menos para *.csv* y *.txt*).

. . .

En la carpeta `/Data` se tiene un archivo llamado `Data_FMI.xlsx` que contiene datos económicos para varios países:

<!-- ```{r, out.width='50%'} -->

<!-- #| echo: false -->

<!-- #| fig-align: center -->

<!-- knitr::include_graphics("Imagenes/ExcelFile.png") -->

<!-- ``` -->

![](Imagenes/ExcelFile.png){.absolute top="250" left="200" width="600" height="450"}

------------------------------------------------------------------------

¿Cómo leer este archivo en `R`? Para ello, primero debemos cargar el paquete `readr`:

```{r}
library(readr)
```

. . .

Luego, podemos leer el archivo *.csv* utilizando la función `read_csv()`. Antes de leerlo, debemos asegurarnos de que el archivo está en la carpeta correcta y se utiliza la *ruta* adecuada:

```{r}
#| message: true
data <- readr::read_csv("Data/Data_FMI.csv")
```

. . .

<br>

En este caso, la función me devuelve información sobre el archivo. Sin embargo, no podemos ver los datos directamente en la consola. Para ello, tenemos varias alternativas.

---

Las alternativas son:

. . . 

1.  Click en el nombre del objeto `data` en la pestaña de *Environment*.
2.  Utilizar la función `View(data)` para abrir una ventana de visualización de datos
3.  Utilizar la función `head(data)` para ver las primeras filas del dataframe en la consola o `tail(data)` para ver las últimas filas.

------------------------------------------------------------------------

Utilizando la 3ra opción, podemos ver las primeras filas del dataframe:

```{r}
head(data)
tail(data)
```

---

<br>
<br>
<br>
<br>
<br>

::: {.callout-note title="Nota"}
Cuando se utilizaron las funciones `head()` o `tail()`, se imprimieron las primeras o últimas filas del dataframe pero, en lugar de decir _"a data.frame: 6 x 10"_, indicó _"a **tibble**: 6 x 10"_. `tibble` es una estructura _casi idéntica_ a un dataframe. Para fines prácticos vamos a decir que es como un dataframe pero que imprime la información algo más ordenada. Para mayor detalle, escribir `vignette(tibble)` en la consola.
:::

## Leyendo archivos *.xlsx*

Otro tipo de archivos común son los archivos de Excel con extensión *.xlsx*. Para leer estos archivos, utilizamos el paquete `readxl`, que también forma parte del `tidyverse`, aunque no se carga automáticamente al cargar `tidyverse`.

. . .

Lo primero que se debe hacer es instalar el paquete `readxl` si no se ha hecho previamente:

```{r, eval=FALSE}
install.packages("readxl")
```

. . .

<br>

Luego, se carga el paquete:

```{r}
#| message: true
library(readxl)
```

--- 

En la carpeta `/Data` se tiene un archivo llamado `Data_FMI.xlsx`, igual que el anterior. Para leer este archivo, utilizamos la función `read_excel()` del paquete `readxl`:



```{r}
#| message: true
data_xlsx <- readxl::read_excel("Data/Data_FMI.xlsx")
```

. . .

Al igual que con los archivos *.csv*, podemos ver los datos utilizando las funciones `View()`, `head()` o `tail()`:

```{r}
head(data_xlsx)
```

---

<br>
<br>
<br>
<br>
<br>

::: {.callout-note title="Nota"}
Nótese que se ha usado la notación `readxl::read_excel()` para especificar que estamos utilizando la función `read_excel()` del paquete `readxl`, aunque no era estrictamente necesario si ya se ha cargado el paquete con `library(readxl)`.
:::

# Manipulación de datos con `dplyr`

La manipulación de datos es un proceso clave en el análisis de datos. Consiste en preparar y transformar conjuntos de datos para realizar análisis efectivos. El paquete `dplyr` del ecosistema `Tidyverse` proporciona herramientas simples pero poderosas para lograr esto.

## Objetivos

Esta sección es relativamente larga, pero quizás de las más importantes del curso. 

. . .

El objetivo es aprender a manipular datos en `R`, de tal manera que nos sintamos cómodos navegando y transformando conjuntos de datos. Se estudiará:

| Función        | Descripción breve              |
| -------------- | ------------------------------ |
| `filter()`     | Filtra observaciones           |
| `select()`     | Seleccionar columnas           |
| `mutate()`     | Añadir o modificar variables    |
| `arrange()`    | Ordenar observaciones           |
| `group_by()`   | Agrupar observaciones           |
| `summarise()`  | Resumir datos por grupos        |

. . .

::: {.callout-note title="Nota"}
En esta clase vamos a llamar **observación** a una fila individual dentro de un conjunto de datos y **variable** a una columna que representa una característica o atributo del conjunto de datos.
:::

## El operador `%>%` o `|>` (pipe)

El operador `|>` (`Ctrl + Shift + M` en Windows o `Cmd + Shift + M` en Mac) permite encadenar operaciones de manera más legible y eficiente. Este operador toma el resultado de una operación y lo pasa como primer argumento a la siguiente función:

```r
resultado <- datos |>
  paso1() |>
  paso2() |>
  paso3()
```

. . . 

Cuando se requieren muchos cálculos, mejora considerablemente la **legibilidad** del código y reduce la necesidad de **variables intermedias**. Por ejemplo:

```{r}
data |> 
  head()
```


## Seleccionar filas con `filter()`

El verbo `filter()` se utiliza para seleccionar filas específicas de un dataframe según condiciones lógicas. 


::::: columns
:::: {.column width="50%"}
::: {.fragment fragment-index="1"}

- Supongamos que se tiene el siguiente dataset, y se desea obtener solo las observaciones del año 2012.

| País   | Año  | Valor |
| ------ | ---- | ----- |
| Bolivia | 2011 | 40.0  |
| Bolivia | 2012 | 44.0  |
| España | 2011 | 60.0  |
| España | 2012 | 35.0  |

:::
::::

:::: {.column width="50%"}
::: {.fragment fragment-index="2"}

- El dataset resultante sería:

<br>

| País   | Año  | Valor |
| ------ | ---- | ----- |
|Bolivia | 2012 | 44.0  |
| España | 2012 | 35.0  |

<br>

- ¿Cómo se haría esto en `R`?

:::
::::
:::::


:::: columns
::: {.column width="50%"}
::: {.fragment fragment-index="3"}

- En el caso tradicional, se utilizaría:

```r
data[data$Año == 2012, ]
```
:::
:::

::: {.column width="50%"}

::: {.fragment data-fragment-index="4"}

- En el caso de `dplyr`, se utilizaría:

```r
data |> 
  filter(Year == 2010)
```

:::
:::
::::


---

Como ya se ha visto antes, se pueden filtrar observaciones basadas en una o más condiciones. Por ejemplo, si se desea filtrar por el país "España" y el año 2012:

::::: columns
:::: {.column width="50%"}
::: {.fragment fragment-index="1"}

- El dataset original es:

| País   | Año  | Valor |
| ------ | ---- | ----- |
| Bolivia | 2011 | 40.0  |
| Bolivia | 2012 | 44.0  |
| España | 2011 | 60.0  |
| España | 2012 | 35.0  |

:::
::::

:::: {.column width="50%"}
::: {.fragment fragment-index="2"}

- El dataset resultante sería:

<br>

| País   | Año  | Valor |
| ------ | ---- | ----- |
| España | 2012 | 35.0  |

<br>

- ¿Cómo se haría esto en `R`?

:::
::::
:::::

::::: columns
:::: {.column width="50%"}
::: {.fragment fragment-index="3"}

- En el caso tradicional, se utilizaría:

```r
data[data$País == "España" & data$Año == 2012, ]
```
:::
::::
:::: {.column width="50%"}
::: {.fragment data-fragment-index="4"}
- En el caso de `dplyr`, se utilizaría:
```r
data |> 
  filter(País == "España", Año == 2012)
```
:::
::::
:::::

---

### Operadores lógicos en `filter()`

El verbo `filter()` permite utilizar varios operadores lógicos para filtrar datos. A continuación, se presentan los operadores más comunes que se pueden utilizar dentro de `filter()`:

<div style="font-size: 70%">
| Descripción        | Operador | Ejemplo (dentro de `filter()`) |
|-----------------------|:----------:|-------------------------------|
| Mayor que         | `>`      | `filter(x > 10)`            |
| Mayor o igual que | `>=`     | `filter(x >= 10)`           |
| Menor que         | `<`      | `filter(x < 10)`            |
| Menor o igual que | `<=`     | `filter(x <= 10)`           |
| Igual a           | `==`     | `filter(x == 10)`           |
| Distinto de       | `!=`     | `filter(x != 10)`           |
| Pertenencia       | `%in%`   | `filter(x %in% c(1, 2, 3))` |
| No pertenece      | `! %in%` | `filter(!(x %in% c(1, 2, 3)))` |
| Es NA (faltante)  | `is.na()`| `filter(is.na(x))`          |
| No es NA          | `!is.na()`| `filter(!is.na(x))`        |
| Negación general | `!`      | `filter(!(x > 10))`         |
| Y lógico         | `&`      | `filter(x > 10 & y < 5)`    |
| O lógico         | `|`     | `filter(x > 10 | y < 5)`   |
</div>

---

### Ejercicios de filtrado

Ahora vamos a practicar el uso de `filter()` con algunos ejercicios, utilizando el dataset `data` que hemos importado anteriormente. En concreto:

<div style="font-size: 80%">

1. Crear un dataset llamado `data_23` que contenga solo las observaciones del año 2023.
1. Crear un dataset llamado `data_bolivia` que contenga solo las observaciones de "Bolivia".
1. Crear un dataset llamado `data_bol_2000` que contenga solo las observaciones de "Bolivia" del año 2000 en adelante.
1. Crear un dataset llamado `data_bol_deficit` que contenga los datos de "Bolivia" donde el déficit fiscal sea mayor a 10%.
1. Crear un dataset llamado `data_bol` que contenga las observaciones de "Bolivia" del año 1981 a 2023.

</div>
<div style="display: flex; justify-content: center; margin-top: 0.5em">
:::{.timer #Hola seconds=360 starton=interaction}
:::
</div>

---

El siguiente dataset se utilizará para los ejercicios:

```{r}
data_bol <- data |> 
  filter(Pais == "Bolivia", Año >= 1981, Año <= 2023)

tail(data_bol)
```

. . .

<br>

:::{.callout-warning title="Recordar"}
De ahora en adelante para ilustrar la mayoría de los ejemplos, se utilizará el dataset `data_bol` que hemos definido anteriormente, el cual contiene las observaciones de "Bolivia" del año 1981 a 2023.
:::


## Seleccionar columnas con `select()`

El verbo `select()` se utiliza para seleccionar columnas en un dataframe. Permite trabajar con un subconjunto de las columnas disponibles.

. . .

Por ejemplo, si se desea seleccionar las columnas `Pais`, `Año` y `GDPpc_usd` del dataset `data_bol`, se puede hacer de la siguiente manera:

```{r}
data_bol |> 
  select(Pais, Año, GDPpc_usd)
```

---

El verbo `select()` también permite seleccionar columnas por rango, por ejemplo, si se desea seleccionar las columnas de `Año` a `Inflacion`, se puede hacer de la siguiente manera:

```{r}
data_bol |> 
  select(Año:Inflacion)
```

---

También se pueden _excluir_ columnas específicas utilizando el operador `-`. Por ejemplo, si se desea excluir la columna `GDPpc_usd` y `ISO_Code`, se puede hacer de la siguiente manera:

```{r}
data_bol |> 
  select(-GDPpc_usd, -ISO_Code)
```

---

### Uso de "helpers" en `select()`

`select()` también permite el uso de "helpers" para seleccionar columnas de manera más flexible. Algunos de los más comunes son:

| Helper            | Descripción                                      |
|-------------------|--------------------------------------------------|
| `starts_with()`   | Selecciona columnas que comienzan con un prefijo |
| `ends_with()`     | Selecciona columnas que terminan con un sufijo   |
| `contains()`      | Selecciona columnas que contienen una cadena     |
| `everything()`    | Selecciona todas las columnas                    |
| `where()`         | Selecciona columnas según una condición lógica   |


Estos "helpers" también forman parte de `dplyr` y permiten una selección más dinámica de columnas. 

---

Así, supongamos que se desea:

:::::columns
:::: {.column width="50%"}
:::: {.fragment fragment-index="1"}
- Seleccionar la columna `Año` y todas las columnas que comienzan con "GDP":

```{r}
data_bol |> 
  select(Año, starts_with("GDP"))
```

:::
::::
:::: {.column width="50%"}
:::: {.fragment fragment-index="2"}
- Seleccionar solo aquellas columnas que son de texto:

```{r}
data_bol |> 
  select(where(is.character))
```

:::
::::
:::::

## Crear y modificar variables con `mutate()`

Un verbo clave de `dplyr` es `mutate()`, que se utiliza para crear nuevas variables o modificar las existentes en un dataframe.

. . . 


Por ejemplo, si se desea crear una nueva variable llamada `GDPpc_milesUSD` que sea el PIB per cápita en miles de dólares:

```{r}
data_tmp <- data_bol |> 
  mutate(GDPpc_milesUSD = GDPpc_usd / 1000)

data_tmp |> 
  select(Pais, Año, GDPpc_usd, GDPpc_milesUSD)
```


---

Otro uso común de `mutate()` es para crear variables de forma condicional. Es decir, que se tome un valor si se cumple una condición y otro valor si no se cumple. Para esto, se suele utilizar la función `if_else`, también parte de `dplyr`.

. . . 

Por ejemplo, supongamos que se desea crear una nueva variable llamada `cuentas_en` que tome el valor de `deficit` si la variable `Deficit_Fiscal` es menor a 0 y `superavit` si es mayor o igual a 0:

```{r}
data_tmp <- data_bol |> 
  mutate(cuentas_en = if_else(Deficit_Fiscal < 0, "deficit", "superavit"))

data_tmp |>
  select(Pais, Año, Deficit_Fiscal, cuentas_en)
```


---

Finalmente, muchas veces se quieren crear nuevas categorías en base a valores numéricos. Por ejemplo, si se desea crear una nueva variable llamada `Inflacion_Categoria` que tome el valor de `baja` si la inflación es menor a 5%, `media` si está entre 5% y 10%, y `alta` si es mayor a 10%:

```{r}
data_tmp <- data_bol |> 
  mutate(Inflacion_Categoria = case_when(
    Inflacion < 5 ~ "Baja",
    Inflacion >= 5 & Inflacion < 10 ~ "Media",
    Inflacion >= 10 & Inflacion < 50 ~ "Alta",
    Inflacion >= 50 ~ "Muy alta"
  ))

data_tmp |>
  select(Pais, Año, Inflacion, Inflacion_Categoria)
```


## Combinar verbos con `pipe` 

Anteriormente, se indicó que era posible utilizar el operador `%>%` o `|>` para encadenar operaciones. Esto es especialmente útil cuando se combinan varios verbos de `dplyr`.

. . .

<br>
Por ejemplo, en el caso anterior, se creó una nueva variable `cuentas_en` para indicar si el país tenía un déficit o superávit fiscal. El resultado fue un nuevo dataframe `data_tmp` que contenía la nueva variable. Sobre este se aplico el vebo `select()` para mostrar solo las columnas de interés.

. . .

<br>

Aunque funcionó, no es la manera más eficiente de hacerlo. En lugar de crear un dataframe intermedio, se puede encadenar las operaciones directamente utilizando el operador `%>%` o `|>`.



---

Por ejemplo, supongamos que se desea crear la variable `cuentas_en` y luego seleccionar las columnas `Pais`, `Año`, `Deficit_Fiscal` y `cuentas_en` en un solo paso:

```{r}
data_bol |> 
  mutate(cuentas_en = if_else(Deficit_Fiscal < 0, "deficit", "superavit")) |>
  select(Pais, Año, Deficit_Fiscal, cuentas_en)
```

---

Nótese que el encadenamiento de operaciones no tiene porqué quedar ahí. Supongamos que ahora solo queremos ver las observaciones donde `cuentas_en` es "superavit". Podemos agregar otro verbo `filter()` al final de la cadena:

```{r}
data_bol |> 
  mutate(cuentas_en = if_else(Deficit_Fiscal < 0, "deficit", "superavit")) |>
  select(Pais, Año, Deficit_Fiscal, cuentas_en) |>
  filter(cuentas_en == "superavit")
```

. . . 

<br>

Esto es lo que hace el ecosistema `Tidyverse` tan poderoso: la capacidad de combinar múltiples operaciones de manera fluida, legible y secuencial, tal como se haría en un flujo de trabajo natural.


--- 

<br>
<br>
<br>
<br>
<br>

:::{.callout-warning title="Recordar"}
De ahora en adelante, vamos a utilizar el operador `|>` para encadenar operaciones de `dplyr`, aunque también se puede utilizar el operador `%>%`.
:::


## Ordenar datos con `arrange()`

Otro verbo que suele ser muy útil es `arrange()`, que se utiliza para ordenar las observaciones de un dataframe según una o más variables. Por ejemplo,

::::: columns
:::: {.column width="50%"}
:::{.fragment data-fragment-index="1"}
- Ordenar el dataset de acuerdo a los años de mayor a menor inflación:

```{r}
data_bol |> 
  select(Pais, Año, Inflacion) |>
  arrange(desc(Inflacion))
```

:::
::::

:::: {.column width="50%"}
:::{.fragment data-fragment-index="2"}

- Ordenar de acuerdo a los años de menor a mayor inflación:

```{r}
data_bol |> 
  select(Pais, Año, Inflacion) |>
  arrange(Inflacion)
```

:::
::::
:::::

## Operaciones agrupadas con `group_by()`

Uno de los verbos más poderosos de `dplyr` es `group_by()`, que permite agrupar datos por una o más variables. 

. . . 

Para demostrar su uso, vamos a crear un nuevo conjunto de datos, tomando en cuenta algunos paises vecinos para los años 2022 y 2023:

```{r}
data_vecinos <- data |> 
  filter(Pais %in% c("Bolivia", "Peru", "Chile", "Paraguay"), 
         Año %in% c(2022, 2023)) |> 
  select(Pais, Año, Inflacion)

data_vecinos 
```

---

Conceptualmente, ¿qué es lo que hace `group_by()`?

::::: columns
:::: {.column width="40%"}
:::{.fragment data-fragment-index="1"}

- Añade una especie de identificador (interno) 
  a cada observación del dataframe, de acuerdo a la o las variables que se le indiquen.

```{r}
data_vecinos |> 
  group_by(Pais)
```

:::
::::
:::: {.column width="60%"}

:::{.fragment data-fragment-index="2"}
- Visto gráficamente, es como si se separara el dataframe en varios subconjuntos, uno por cada grupo definido por la o las variables indicadas.
  
  
```{r}
#| echo: false

library(dplyr)
library(knitr)
library(kableExtra)


# Definimos el color por grupo
data_color <- data_vecinos |> 
  mutate(color = case_when(
    Pais == "Bolivia" ~ "lightgreen",
    Pais == "Chile" ~ "lightblue",
    Pais == "Paraguay" ~ "lightgray",
    Pais == "Peru" ~ "lightcoral",
  ))

data_vecinos %>%
  kable("html", escape = FALSE) |> 
  kable_styling(full_width = FALSE) |> 
  row_spec(0, bold = TRUE) |> 
  row_spec(1, background = data_color$color[1]) |> 
  row_spec(2, background = data_color$color[2]) |> 
  row_spec(3, background = data_color$color[3]) |> 
  row_spec(4, background = data_color$color[4]) |> 
  row_spec(5, background = data_color$color[5]) |> 
  row_spec(6, background = data_color$color[6]) |> 
  row_spec(7, background = data_color$color[7]) |> 
  row_spec(8, background = data_color$color[8]) 
```

:::
::::
:::::

---

### Operaciones con `group_by()`: `summarise()`

`group_by()` es especialmente útil cuando se combina con `summarise()`, que permite calcular estadísticas resumidas para cada grupo. Por ejemplo, si se desea calcular la inflación promedio por país.

::::: columns
:::: {.column width="50%"}
:::{.fragment data-fragment-index="1"}


```{r}
#| eval: false
#| 
data_vecinos |> 
  group_by(Pais)
```

```{r}
#| echo: false
data_vecinos %>%
  kable("html", escape = FALSE) |> 
  kable_styling(full_width = FALSE) |> 
  row_spec(0, bold = TRUE) |> 
  row_spec(1, background = data_color$color[1]) |> 
  row_spec(2, background = data_color$color[2]) |> 
  row_spec(3, background = data_color$color[3]) |> 
  row_spec(4, background = data_color$color[4]) |> 
  row_spec(5, background = data_color$color[5]) |> 
  row_spec(6, background = data_color$color[6]) |> 
  row_spec(7, background = data_color$color[7]) |> 
  row_spec(8, background = data_color$color[8]) 
```

:::
::::

:::: {.column width="50%"}
:::{.fragment data-fragment-index="2"}

```{r}
#| eval: false
data_vecinos |> 
  group_by(Pais) |> 
  summarise(Inflacion_Promedio = mean(Inflacion))
```

```{r}
#| echo: false

data_color_2 <- data_vecinos |> 
  group_by(Pais) |>
  summarise(Inflacion_Promedio = mean(Inflacion)) |>
  mutate(color = case_when(
    Pais == "Bolivia" ~ "lightgreen",
    Pais == "Chile" ~ "lightblue",
    Pais == "Paraguay" ~ "lightgray",
    Pais == "Peru" ~ "lightcoral",
  ))

data_vecinos |> 
  group_by(Pais) |>
  summarise(Inflacion_Promedio = mean(Inflacion)) |>
  kable("html", escape = FALSE) |> 
  kable_styling(full_width = FALSE) |> 
  row_spec(0, bold = TRUE) |> 
  row_spec(1, background = data_color_2$color[1]) |> 
  row_spec(2, background = data_color_2$color[2]) |> 
  row_spec(3, background = data_color_2$color[3]) |> 
  row_spec(4, background = data_color_2$color[4]) 
```
:::
::::
:::::

---

### Más sobre `summarise()`


:::{.fragment data-fragment-index="0"}
`summarise()` no se limita a calcular promedios, sino que también permite calcular otras estadísticas como sumas, medianas, máximos, mínimos, etc. Por ejemplo:
:::

:::::{.fragment data-fragment-index="1"}
:::: columns
::: {.column width="30%"}
[Basado en el país]{style="font-weight:bold;background-color:#ccddeb;"}, calcular el número de observaciones, la inflación promedio y la inflación máxima. Los resultados desplegarlos ordenando los países en orden alfabético, pero iniciando en la "Z".
:::

::: {.column width="70%"}
```{r}
#| code-line-numbers: "2"
data_vecinos |> 
  group_by(Pais)
```

:::
::::
:::::

---

### Más sobre `summarise()`


`summarise()` no se limita a calcular promedios, sino que también permite calcular otras estadísticas como sumas, medianas, máximos, mínimos, etc. Por ejemplo:

:::: columns
::: {.column width="30%"}
Basado en el país, [calcular el número de observaciones]{style="font-weight:bold;background-color:#ccddeb;"}, la inflación promedio y la inflación máxima. Los resultados desplegarlos ordenando los países en orden alfabético, pero iniciando en la "Z".
:::

::: {.column width="70%"}
```{r}
#| code-line-numbers: "3-5"
data_vecinos |> 
  group_by(Pais) |> 
  summarise(
    Obs = n()
    )
```

:::
::::


---

### Más sobre `summarise()`


`summarise()` no se limita a calcular promedios, sino que también permite calcular otras estadísticas como sumas, medianas, máximos, mínimos, etc. Por ejemplo:

:::: columns
::: {.column width="30%"}
Basado en el país, calcular el número de observaciones, [la inflación promedio]{style="font-weight:bold;background-color:#ccddeb;"} y la inflación máxima. Los resultados desplegarlos ordenando los países en orden alfabético, pero iniciando en la "Z".
:::

::: {.column width="70%"}
```{r}
#| code-line-numbers: "5"
data_vecinos |> 
  group_by(Pais) |> 
  summarise(
    Obs = n(),
    Inf_prom = mean(Inflacion)
    )
```

:::
::::


---

### Más sobre `summarise()`


`summarise()` no se limita a calcular promedios, sino que también permite calcular otras estadísticas como sumas, medianas, máximos, mínimos, etc. Por ejemplo:

:::: columns
::: {.column width="30%"}
Basado en el país, calcular el número de observaciones, la inflación promedio y [la inflación máxima]{style="font-weight:bold;background-color:#ccddeb;"}. Los resultados desplegarlos ordenando los países en orden alfabético, pero iniciando en la "Z".
:::

::: {.column width="70%"}
```{r}
#| code-line-numbers: "6"
data_vecinos |> 
  group_by(Pais) |> 
  summarise(
    Obs = n(),
    Inf_prom = mean(Inflacion),
    Inf_max = max(Inflacion)
    )
```

:::
::::


---

### Más sobre `summarise()`

:::::{.fragment data-fragment-index="0"}
`summarise()` no se limita a calcular promedios, sino que también permite calcular otras estadísticas como sumas, medianas, máximos, mínimos, etc. Por ejemplo:

:::: columns
::: {.column width="30%"}
Basado en el país, calcular el número de observaciones, la inflación promedio y la inflación máxima. [Los resultados desplegarlos ordenando los países en orden alfabético, pero iniciando en la "Z".]{style="font-weight:bold;background-color:#ccddeb;"}
:::
::: {.column width="70%"}
```{r}
#| code-line-numbers: "8"
data_vecinos |> 
  group_by(Pais) |> 
  summarise(
    Obs = n(),
    Inf_prom = mean(Inflacion),
    Inf_max = max(Inflacion),
    ) |> 
  arrange(desc(Pais))
```

:::
::::
:::::

:::::{.fragment data-fragment-index="1"}
Nótese cómo, utilizando la sintaxis de `dplyr` es posible combinar múltiples operaciones de manera fluida y realizar la mayoría de las operaciones con pocas líneas de código.
:::::


---

### Ejercicios

Ahora vamos a practicar el uso de las distintos verbos de `dplyr` con algunos ejercicios, utilizando el dataset original, `data`, que hemos importado anteriormente. En particular, se pide responder:

1. ¿Cuál es el crecimiento promedio del PIB mundial para los años 2022 y 2023?
1. ¿Cuál es el crecimiento promedio del PIB para cada continente en el año 2023? Mostrar los resultados en orden descendente.
1. ¿Cuál es el promedio del déficit fiscal y la deuda para los países del continente americano?
1. ¿Qué países tuvieron más de 15% de inflación en el año 2023?
1.  ¿Existe alguna relación entre el nivel de deuda y la inflación? Para esto, clasificar la deuda en tres grupos: baja (menos de 40%), media (entre 50% y 80%) y alta (más de 80%). Luego, calcular la inflación promedio para cada grupo de deuda.




# Resumen

En esta clase hemos aprendido a importar y manipular datos en `R` utilizando el ecosistema `Tidyverse`, específicamente los paquetes `readr` y `dplyr`. En particular, hemos visto cómo:

| Función        | Descripción breve              |
| -------------- | ------------------------------ |
| `readr::read_csv()`   | Importa archivos CSV           |
| `readxl::read_excel()` | Importa archivos Excel         |
| `filter()`     | Filtra observaciones           |
| `select()`     | Selecciona o renombra columnas |
| `mutate()`     | Añade o modifica variables     |
| `arrange()`    | Ordena observaciones           |
| `group_by()`  | Agrupa datos por variables      |
| `summarise()`  | Calcula estadísticas resumidas |


## Próximos pasos

En la siguiente clase exploraremos visualizaciones con [`ggplot2`](https://ggplot2.tidyverse.org/), utilizando los datos transformados en esta sesión.

. . .

De todas maneras, para ver el potencial de esta herramienta, páginas como the [The R Graph Gallery](https://r-graph-gallery.com/ggplot2-package.html) proveen algunos ejemplos e inspiración de gráficos que se pueden hacer con `ggplot2`.


